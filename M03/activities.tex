\subsection{Activities}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Camera mount design}
\begin{itemize}
	\item The electronic components were received this Monday.
	\item Measurements of the size of the camera and its PCB components were taken.
	\item After observing Carrita's front structure the only readily available mounting point was identified as a thin plate with four screw holes.
	\item Measurements of this thin plate were taken.
	\item A camera mount was designed aiming at:
	\begin{itemize}
		\item Centered cameras.
		\item Aligned cameras.
		\item Fixed, constant distance between cameras.
		\item Keeping a DOF (angle/inclination of view towards the floor).
	\end{itemize}
	\item CAD software was used to draft mechanisms and spot possible conflicts.
	\item After solving some design conflicts found the original concept part and drawings files were generated.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Edge detection research}
As mentioned in previous sections, the code used used for edge detection is from FAST-EDGE project. Some modifications were done to the arguments of the functions, the file loading code was removed and the functions were used to work directly on memory.

The code does mainly two things:
\begin{itemize}
	\item Gaussian blurs the image.
	\item Detectes and draws edges (white) over a black background.
\end{itemize}

These two processes' input and output were well known by me but their internals were not. I studied these topics to know which optimizations could be done to the code and which lacking functionality could be added.

The following conclussions can be made after studying the code and the theory behind it:
\begin{itemize}
	\item Region of interest (ROI) can be added to the code to avoid running the function on the whole image if it is not necessary.
	\item Functions are not inlined. This does not guarantee the compiler is not inlining but it is a potential boost.
	\item Fixed-point arithmetic is not used either.
\end{itemize}

The most useful and interesting finding of this research was that the code looked like it could be implemented on a GPU. This topic is presented in the next section.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{General-purpose computing on graphics processing units}

Graphical processing units are highly parallelized processors used (mostly) for graphics. Central processing units may have multiple cores but they are far of being as powerful as a GPU when it comes to solving computations which can be parallelized. While reading the code behind edge detection I remembered GPGPU, which is using the GPU for computations typically done by a CPU (i.e. not graphics). 

Some GPU vendors have introduced or are introducing interfaces to freely use the GPU. The main open project for this is called OpenCL. For processors without OpenCL support, GPGPU computation has been done using OpenGL shaders to perform graphics-unrelated computations by mapping them to a graphics space (performing calculations of fast fourier transform and other digital signal processing operations much faster than on the host CPU).

Some (the most important) research results for related GPU published work are:
\begin{itemize}
	\item OpenCL is not supported on the Raspberry Pi.
	\item Raspberry Pi's OpenGL implementation is a complete OpenGL ES 2.0.
	\item This is a video\cite{cummings} showing Pi’s GPU computing and displaying sixteen textures.
	\begin{itemize}
		\item One of them is a Gaussian filter.
		\item All are drawn at the same time in real time.
		\item Output is sent out through HDMI 1080p.
		\item OpenGLSL code is available.
	\end{itemize}
	\item Markéta Dubská et al.\cite{dubska} show a GPU implementation of line detection using OpenGLSL.
	\begin{itemize}
		\item The GPU implementation outperforms OpenCV running on all the cores of an i7-920 processor.
		\item Code not available.
	\end{itemize}
	\item I have experience using OpenGL for graphics but not for computations.
	\item I began to study OpenGLSL because its an area worth of exploration.
	\begin{itemize}
		\item It has space for research and inovation.
		\item Impact on any device with an OpenGL ES 2.0 capable video card.
		\item This includes most smartphones
		\item Previous experience with OpenGL makes spending time on this less costly.
		\item On full success this will boost our possibilities significantly.
		\item Otherwise it will still help a bit.
	\end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{STM32 - IDE installation}

\begin{itemize}
	\item IDE options exploration.
	\item Two were installed and tested on Windows based on internet resources.
	\begin{itemize}
		\item CrossWorks for ARM.
		\item IAR Embedded Workbench ARM v7.10.
	\end{itemize}
	\item IAR Embedded Workbench will be used for the project because ST provides ready to use projects for it.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{STM32 - SPI and DMA}
\begin{itemize}
	\item A communication test with the Raspberry Pi was performed, confirming the following keypoints work:
	\begin{itemize}
		\item IDE.
		\item Programmer.
		\item Debugger.
		\item SPI (slave mode) and DMA (memory to peripheral).
	\end{itemize}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Raspberry Pi - SPI}

The most common (and documented) way of accessing the SPI peripheral on the Raspberry Pi is through the Linux kernel module (whether accessed from python, shell, C). I knew it was not the fastest option but I did not know how the fastest one work. After the corresponding research and tests it can be noted that:

\begin{itemize}
	\item Kernel's SPI module does not allow "full freedom" access to the chip peripheral.
	\item This limits the transfer speed.
	\item bcm2835 library allows low-level access using high-level programming.
	\item The library was compiled and installed.
	\item A communication test with the STM32 was successfully done.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Raspberry Pi - Performance improvements}

\begin{itemize}
\item \textbf{GPU.} Already explained at another section. 
\item \textbf{Bare bones.} After finding the Linux is not needed for SPI usage the question about whether it was needed for anything arose and it turned out to be possible to run ARM code directly from the SD card. Work has been done on that. This is just something to have in mind because there are some very useful Linux features that are still needed (drivers, process management, pipelines).
\item \textbf{Overclocking.} An official maximum overclock was performed, this sets the Raspberry Pi clock at 1 GHz (42\% faster than without overclock).
\item \textbf{Shutdown unused modules.} Some Linux modules can be turned off to save CPU usage. That was known but an interesting finding was that the HDMI output can be turned off (which is a relatively heavy process that will not be needed). This is something to have in mind: turning down as many things as possible.
\end{itemize}
